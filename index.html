<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pac-Man (HTML)</title>
  <style>
    :root { --bg:#000; --fg:#ffd400; --wall:#1e5bff; --text:#cbd5e1; }
    body{ margin:0; background:var(--bg); color:var(--text); font-family:system-ui,Segoe UI,Roboto,Arial; min-height:100vh; display:flex; align-items:center; justify-content:center; }
    .wrap{ text-align:center; padding:16px; }
    canvas{ background:#000; border:1px solid #111; image-rendering: pixelated; max-width: 100%; height:auto; }
    .hud{ margin-top:10px; font-size:14px; color:#94a3b8; }
    .hud b{ color:#fff; }
    .row{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
    .btn{ background:#111827; color:#e2e8f0; border:1px solid #334155; padding:8px 10px; border-radius:10px; cursor:pointer; }
    .btn:hover{ background:#0b1220; }
  </style>
</head>
<body>
<div class="wrap">
  <canvas id="c" width="672" height="768"></canvas>
  <div class="hud">
    <div class="row"><b>Pac-Man</b> — arrow keys / WASD • Eat all pellets • Avoid ghosts</div>
    <div class="row"><span id="status"></span></div>
    <div class="row">
      <button class="btn" id="restart">Restart</button>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');
  const restartBtn = document.getElementById('restart');

  const keys = Object.create(null);
  addEventListener('keydown', e => { keys[e.key] = true; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault(); }, {passive:false});
  addEventListener('keyup', e => keys[e.key] = false);

  // Grid
  const TILE = 24;
  const COLS = 28;
  const ROWS = 32;
  canvas.width = COLS * TILE;
  canvas.height = ROWS * TILE;

  // Legend:
  // # wall
  // . pellet
  // o power pellet
  // ' ' empty
  // P pacman spawn
  // G ghost spawn
  const LEVEL = [
    "############################",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#o####.#####.##.#####.####o#",
    "#.####.#####.##.#####.####.#",
    "#..........................#",
    "#.####.##.########.##.####.#",
    "#.####.##.########.##.####.#",
    "#......##....##....##......#",
    "######.##### ## #####.######",
    "     #.##### ## #####.#     ",
    "     #.##          ##.#     ",
    "     #.## ###GG### ##.#     ",
    "######.## #      # ##.######",
    "      .   #      #   .      ",
    "######.## #      # ##.######",
    "     #.## ######## ##.#     ",
    "     #.##          ##.#     ",
    "     #.## ######## ##.#     ",
    "######.## ######## ##.######",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#o..##.......P........##..o#",
    "###.##.##.########.##.##.###",
    "#......##....##....##......#",
    "#.##########.##.##########.#",
    "#.##########.##.##########.#",
    "#..........................#",
    "############################",
  ];

  // Expand to ROWS by padding empty rows (so HUD space at bottom/top is not needed)
  const grid = [];
  for (let r = 0; r < ROWS; r++) {
    const src = LEVEL[r] ?? "";
    const line = (src + " ".repeat(COLS)).slice(0, COLS);
    grid.push(line.split(''));
  }

  const dirs = {
    up:    {x:0,y:-1, key:['ArrowUp','w','W']},
    down:  {x:0,y:1,  key:['ArrowDown','s','S']},
    left:  {x:-1,y:0, key:['ArrowLeft','a','A']},
    right: {x:1,y:0,  key:['ArrowRight','d','D']},
  };

  function isWall(cx, cy) {
    if (cy < 0 || cy >= ROWS) return true;
    if (cx < 0 || cx >= COLS) return true;
    return grid[cy][cx] === '#';
  }

  function tileCenter(cx, cy) {
    return { x: cx*TILE + TILE/2, y: cy*TILE + TILE/2 };
  }

  function findSpawns() {
    let pac = null;
    const ghosts = [];
    for (let y=0; y<ROWS; y++) for (let x=0; x<COLS; x++) {
      if (grid[y][x] === 'P') pac = {x,y};
      if (grid[y][x] === 'G') ghosts.push({x,y});
    }
    if (!pac) pac = {x: 13, y: 23};
    return { pac, ghosts };
  }

  function countPellets() {
    let n=0;
    for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) {
      if (grid[y][x] === '.' || grid[y][x] === 'o') n++;
    }
    return n;
  }

  // Entities use pixel positions but must align to grid when turning.
  function newPacman(spawn) {
    const c = tileCenter(spawn.x, spawn.y);
    return {
      x: c.x,
      y: c.y,
      dir: {x:1,y:0},
      wish: {x:1,y:0},
      speed: 2.4,
      mouth: 0,
      alive: true,
    };
  }

  function newGhost(spawn, color) {
    const c = tileCenter(spawn.x, spawn.y);
    return {
      x: c.x,
      y: c.y,
      dir: {x:0,y:-1},
      speed: 2.0,
      color,
      frightened: 0,
    };
  }

  const ghostColors = ['#ff3b30','#34c759','#0a84ff','#ff9f0a'];

  let pacman;
  let ghosts;
  let score;
  let lives;
  let pelletsLeft;
  let gameOver;
  let win;

  function resetGame() {
    // reset grid pellets (rebuild)
    for (let r = 0; r < ROWS; r++) {
      const src = LEVEL[r] ?? "";
      const line = (src + " ".repeat(COLS)).slice(0, COLS);
      grid[r] = line.split('');
    }

    const sp = findSpawns();
    pacman = newPacman(sp.pac);
    ghosts = sp.ghosts.map((g,i) => newGhost(g, ghostColors[i % ghostColors.length]));
    score = 0;
    lives = 3;
    pelletsLeft = countPellets();
    gameOver = false;
    win = false;
  }

  function resetRound() {
    const sp = findSpawns();
    pacman = newPacman(sp.pac);
    ghosts = sp.ghosts.map((g,i) => newGhost(g, ghostColors[i % ghostColors.length]));
  }

  function keyDir() {
    for (const d of Object.values(dirs)) {
      for (const k of d.key) if (keys[k]) return {x:d.x,y:d.y};
    }
    return null;
  }

  function canMove(px, py, dir) {
    const cx = Math.floor(px / TILE);
    const cy = Math.floor(py / TILE);
    const nx = cx + dir.x;
    const ny = cy + dir.y;
    return !isWall(nx, ny);
  }

  function atCenter(px, py) {
    const cx = Math.floor(px / TILE);
    const cy = Math.floor(py / TILE);
    const c = tileCenter(cx, cy);
    return Math.abs(px - c.x) < 1.2 && Math.abs(py - c.y) < 1.2;
  }

  function snapToCenter(ent) {
    const cx = Math.floor(ent.x / TILE);
    const cy = Math.floor(ent.y / TILE);
    const c = tileCenter(cx, cy);
    ent.x = c.x;
    ent.y = c.y;
  }

  function eatPellet() {
    const cx = Math.floor(pacman.x / TILE);
    const cy = Math.floor(pacman.y / TILE);
    const t = grid[cy]?.[cx];
    if (t === '.' || t === 'o') {
      grid[cy][cx] = ' ';
      pelletsLeft--;
      score += (t === 'o') ? 50 : 10;
      if (t === 'o') {
        for (const g of ghosts) g.frightened = 60 * 7; // ~7 seconds
      }
      if (pelletsLeft <= 0) {
        win = true;
        gameOver = true;
      }
    }
  }

  function dist(a,b) {
    const dx=a.x-b.x, dy=a.y-b.y;
    return Math.hypot(dx,dy);
  }

  function updatePacman() {
    const d = keyDir();
    if (d) pacman.wish = d;

    // attempt turn only when near center
    if (atCenter(pacman.x, pacman.y)) {
      snapToCenter(pacman);
      if (canMove(pacman.x, pacman.y, pacman.wish)) pacman.dir = {...pacman.wish};
      // stop if blocked
      if (!canMove(pacman.x, pacman.y, pacman.dir)) {
        // don't move
      }
    }

    // move
    if (canMove(pacman.x, pacman.y, pacman.dir)) {
      pacman.x += pacman.dir.x * pacman.speed;
      pacman.y += pacman.dir.y * pacman.speed;
    }

    // wrap tunnel (left/right on row 14-ish)
    if (pacman.x < -TILE/2) pacman.x = COLS*TILE + TILE/2;
    if (pacman.x > COLS*TILE + TILE/2) pacman.x = -TILE/2;

    pacman.mouth += 0.18;
    eatPellet();
  }

  function ghostChoices(g) {
    const cx = Math.floor(g.x / TILE);
    const cy = Math.floor(g.y / TILE);
    const options = [];
    const ds = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
    for (const d of ds) {
      // avoid reversing unless forced
      if (d.x === -g.dir.x && d.y === -g.dir.y) continue;
      if (!isWall(cx+d.x, cy+d.y)) options.push(d);
    }
    if (!options.length) {
      // allow reverse
      for (const d of ds) if (!isWall(cx+d.x, cy+d.y)) options.push(d);
    }
    return options;
  }

  function chooseGhostDir(g) {
    const opts = ghostChoices(g);
    if (!opts.length) return;

    // target selection
    const target = g.frightened > 0
      ? { x: Math.random()*COLS*TILE, y: Math.random()*ROWS*TILE }
      : { x: pacman.x, y: pacman.y };

    // choose direction that reduces distance (or increases if frightened)
    let best = null;
    let bestScore = null;
    for (const d of opts) {
      const nx = g.x + d.x*TILE;
      const ny = g.y + d.y*TILE;
      const sc = Math.hypot(target.x - nx, target.y - ny);
      const metric = g.frightened > 0 ? -sc : sc;
      if (bestScore == null || metric < bestScore) {
        bestScore = metric;
        best = d;
      }
    }
    g.dir = best;
  }

  function updateGhost(g) {
    if (g.frightened > 0) g.frightened--;

    // turn at centers
    if (atCenter(g.x, g.y)) {
      snapToCenter(g);
      chooseGhostDir(g);
    }

    const speed = g.frightened > 0 ? 1.6 : g.speed;
    // move
    const cx = Math.floor(g.x / TILE);
    const cy = Math.floor(g.y / TILE);
    if (!isWall(cx + g.dir.x, cy + g.dir.y)) {
      g.x += g.dir.x * speed;
      g.y += g.dir.y * speed;
    }

    if (g.x < -TILE/2) g.x = COLS*TILE + TILE/2;
    if (g.x > COLS*TILE + TILE/2) g.x = -TILE/2;
  }

  function handleCollisions() {
    for (const g of ghosts) {
      if (dist(pacman, g) < 14) {
        if (g.frightened > 0) {
          score += 200;
          // respawn ghost at spawn area
          const sp = findSpawns();
          const home = sp.ghosts[0] || {x:13,y:14};
          const c = tileCenter(home.x, home.y);
          g.x = c.x; g.y = c.y;
          g.frightened = 0;
        } else {
          lives--;
          if (lives <= 0) {
            gameOver = true;
            win = false;
          } else {
            resetRound();
          }
          return;
        }
      }
    }
  }

  function draw() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // walls
    for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) {
      const t = grid[y][x];
      if (t === '#') {
        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--wall').trim() || '#1e5bff';
        ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
      }
    }

    // pellets
    for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++) {
      const t = grid[y][x];
      if (t === '.' || t === 'o') {
        ctx.fillStyle = '#ffd400';
        ctx.beginPath();
        const r = t === 'o' ? 6 : 3;
        ctx.arc(x*TILE + TILE/2, y*TILE + TILE/2, r, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // pacman
    const ang = Math.atan2(pacman.dir.y, pacman.dir.x);
    const open = (Math.sin(pacman.mouth) * 0.25 + 0.35);
    ctx.fillStyle = '#ffd400';
    ctx.beginPath();
    ctx.moveTo(pacman.x, pacman.y);
    ctx.arc(pacman.x, pacman.y, 10, ang + open, ang + Math.PI*2 - open);
    ctx.closePath();
    ctx.fill();

    // ghosts
    for (const g of ghosts) {
      const frightened = g.frightened > 0;
      ctx.fillStyle = frightened ? '#60a5fa' : g.color;
      // body
      ctx.beginPath();
      ctx.arc(g.x, g.y, 10, Math.PI, 0);
      ctx.lineTo(g.x+10, g.y+10);
      ctx.lineTo(g.x-10, g.y+10);
      ctx.closePath();
      ctx.fill();
      // eyes
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(g.x-4, g.y-2, 2.8, 0, Math.PI*2);
      ctx.arc(g.x+4, g.y-2, 2.8, 0, Math.PI*2);
      ctx.fill();
    }

    // HUD
    ctx.fillStyle = '#cbd5e1';
    ctx.font = '16px monospace';
    ctx.fillText(`Score: ${score}`, 10, 20);
    ctx.fillText(`Lives: ${lives}`, canvas.width - 120, 20);
    ctx.fillText(`Pellets: ${pelletsLeft}`, canvas.width/2 - 70, 20);

    if (gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = '40px monospace';
      ctx.fillText(win ? 'YOU WIN!' : 'GAME OVER', canvas.width/2 - 120, canvas.height/2);
      ctx.font = '18px monospace';
      ctx.fillText('Press Restart', canvas.width/2 - 70, canvas.height/2 + 40);
    }

    statusEl.textContent = `Score ${score} • Lives ${lives} • Pellets ${pelletsLeft}`;
  }

  let last = 0;
  function loop(ts) {
    const dt = ts - last;
    last = ts;

    if (!gameOver) {
      // fixed-ish update (dt not used deeply)
      updatePacman();
      for (const g of ghosts) updateGhost(g);
      handleCollisions();
    }
    draw();
    requestAnimationFrame(loop);
  }

  restartBtn.addEventListener('click', resetGame);

  resetGame();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
